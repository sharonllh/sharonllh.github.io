---
layout: post
title: DDIA阅读笔记(7)：分布式数据系统的事务
date: 2024-06-18 +0800
tags: [系统设计, DDIA]
categories: [系统设计]
---

## 事务的概念

事务（transaction）是应用程序把多个读写操作组合成一个逻辑单元的方式。

### ACID的含义

事务提供的安全保证，可以用ACID来描述。

#### A：原子性（Atomicity）

原子性的含义：当事务中有多个写操作，进行到一半时出现故障，数据库能够中止事务，并且丢弃该事务的所有写入。

原子性提供了all-or-nothing的保证，使应用程序不用担心部分失败的情况。

#### C：一致性（Consistency）

一致性的含义：对数据的一组特定约束必须始终成立，即不变式（invariants）。

一致性取决于应用程序，而不是数据库。应用程序需要理解不变式，并正确定义事务。

#### I：隔离性（Isolation）

隔离性的含义：同时执行的事务是互相隔离的，不会互相干扰。如果一个事务进行多个写操作，另一个事务要么看到全部写入的结果，要么什么也看不到。

隔离性可以理解为可串行化（serializability），即当多个事务并发运行时，结果与它们串行运行是一样的。

#### D：持久性（Durability）

持久性的含义：一旦事务成功完成，即使数据库崩溃或者硬件故障了，写入的数据也不会丢失。

在单节点数据库中，持久性通过以下方式来实现：
- 把数据写入非易失性存储设备，如硬盘、SSD。
- 同时把数据写入预写日志，这样可以在数据库崩溃时进行恢复。

在分布式数据库中，持久性的实现方式：等数据被成功复制到多个节点，才报告事务成功。

完美的持久性是不存在。如果所有硬盘和备份都被销毁了，数据肯定就丢失了。

### 单对象和多对象操作

一般数据库对单个节点的单个对象都提供事务保证。有些数据库还会提供更复杂的原子操作，例如：
- 原子自增：在并发的情况下，每次把值增加1。
- 比较和设置（CAS，compare-and-set）：只有在值没有被其他并发修改过时，才执行写操作。

多对象操作也需要事务，例如：
- 在关系数据库中，一个表中的行具有对另一个表中的行的外键引用，更改时需要保证外键正确。
- 在文档数据库中，一个字段可能同时存储在多个文档中，更新该字段时需要保证多个文档中的值都被更新。
- 如果数据库中有次级索引，更新数据时需要同时更新次级索引。

许多分布式数据库没有多对象事务，因为实现比较困难，并且可能会影响可用性。

## 弱隔离级别

当两个事务同时修改一个数据，或者当一个事务读取由另一个事务同时修改的数据时，会出现并发问题。数据库通过事务隔离来隐藏应用开发者的并发问题。

事务的隔离级别可以分为：
- 可串行化：事务的运行结果就像串行运行的一样。会导致性能损失。
- 弱隔离级别：防止一部分而不是所有的并发问题。

### 读已提交（Read Committed）

读已提交是最基本的事务隔离级别，提供了两个保证：
- 没有脏读（dirty reads）：从数据库读时，只能看到已提交的数据。
- 没有脏写（dirty writes）：写入数据库时，只会覆盖已提交的数据。

#### 没有脏读

下图是一个脏读的例子。用户1给用户2发了一封新邮件，会给用户2产生一封未读邮件，并更新未读邮件的计数器。然而，脏读导致用户2只看到了新邮件，却没看到未读邮件的计数器更新。

![DistributedData DirtyReadExample](/assets/img/DDIA_DistributedData_DirtyReadExample.png)

防止脏读的原因：
- 如果事务需要更新多个对象，脏读会导致另一个事务只看到部分更新，造成困惑。
- 如果事务中止，所有写入操作都需要回滚，脏读会导致另一个事务看到需要回滚的数据，造成困惑。

#### 没有脏写

下图是一个脏写的例子。Alice和Bob同时买一辆车，而买车时需要两次数据库写入，一次写入买家，一次写入发票接收人。脏读会导致买家为Bob，而发票接收人为Alice。

![DistributedData DirtyWriteExample](/assets/img/DDIA_DistributedData_DirtyWriteExample.png)

#### 实现读已提交

防止脏写的常见方法是使用行锁（row-level lock）。当事务想要修改某个对象时，首先获得该对象的锁，然后持有到事务完成为止。如果另一个事务也想修改这个对象，就必须等到第一个事务完成后，才能获得锁并继续。使用行锁的过程由数据库自动完成。

防止脏读有两种办法：
1. 使用行锁。如果事务想要读取某个对象，也必须获得该对象的锁。如果另一个进行写入的事务先获得了该锁，进行读取的事务就必须等待。这种方法不好，会影响性能。
2. 返回旧的已提交值。如果事务正在更新某个对象，数据库会记录旧的已提交值，和该事务设置的新值。此时如果另一个事务想要读取这个对象，数据库会返回旧值。

### 快照隔离（Snapshot Isolation）和可重复读（Repeatable Read）

读已提交只是最基本的隔离级别，在使用读已提交时，可能会发生下图所示的异常。

Alice在银行有两个账户，分别有500块。有一个正在执行的事务，把100块从一个账户转移到另一个账户。在事务开始前和结束后，Alice分别查看了两个账户的余额，她发现加起来只有900块了。

这种异常称为读取偏差（read skew），或不可重复读（nonrepeatable read）。

![DistributedData ReadSkewExample](/assets/img/DDIA_DistributedData_ReadSkewExample.png)

对于Alice来说，这个异常是暂时的，只要她过一会儿再重新查询，就能看到正确的余额了。

但是，有些情况是不允许这种读取偏差的：
- 数据库备份：数据库备份可能要花比较长的时间，备份期间是仍然允许写入的。如果备份中包含一些旧的部分和一些新的部分，从这个备份中恢复数据库会导致永久性的数据不一致。
- 分析查询和完整性检查：在进行数据分析和完整性检查时，如果查询到的数据一部分是旧的，一部分是新的，那得到的结果可能毫无意义。

解决读取偏差的常见方法是快照隔离。数据库在特定时间点冻结一致性快照（consistent snapshot），每个事务都从一致性快照读取数据。

快照隔离的特点：读不阻塞写，写不阻塞读。

#### 实现快照隔离

防止脏写的办法和读已提交一样，使用行锁。

防止脏读的办法也类似于读已提交，数据库保留一个对象的多个提交版本，从而让各种正在进行的事务可以读取不同时间点的数据。这种技术称为多版本并发控制（MVCC，multi-version concurrency control）。

下图说明了PostgreSQL是怎么基于MVCC实现快照隔离的。

![DistributedData MVCCExample](/assets/img/DDIA_DistributedData_MVCCExample.png)

- 每个事务开始时，都会被赋予一个唯一的、递增的事务ID（即图中的txid）。
- 当事务向数据库写入时，会在写入的数据上标记该事务的ID，例如：插入数据时，设置`create by`为事务ID，`deleted by`为空；删除数据时，并不会真正删除，而是把`deleted by`设置为事务ID。
- `UPDATE`操作被翻译为`DELETE`和`CREATE`。
- 数据库的垃圾收集过程负责清除那些被标记为删除的数据。

当一个事务从数据库读取时，事务ID决定它可以看见哪些对象，看不见哪些对象。可见性规则如下：
1. 在事务开始时，数据库列出所有正在进行的其他事务，忽略它们的任何写入（即使之后提交了）。
2. 对于事务ID更大的所有事务，忽略它们的任何写入（即使已经提交了）。
3. 对于被中止的事务，忽略它们的任何写入。
4. 除此以外的其他写入都是可见的。

总结来说，只要以下两个条件都成立，那么一个对象就是可见的：
- 读取的事务开始时，已经有事务创建这个对象并提交。
- 读取的事务开始时，没有事务删除这个对象并提交。

快照隔离是读已提交的一般化。快照隔离需要保留一个对象的多个版本，而读已提交只需要保留两个版本：已提交的版本，被覆盖但还没提交的版本。支持快照隔离的数据库通常也会使用MVCC来实现读已提交。

#### 索引如何工作？

在使用MVCC的数据库中，索引有两种工作方式：

1. 索引指向对象的所有版本，查询时过滤掉当前事务不可见的版本。当垃圾收集过程删除旧版本时，同时删除相应的索引条目。
2. 使用就追加的B树，每个写入事务（或一批事务）创建一颗新的B树，作为数据库的一个一致性快照。

### 丢失更新

在读已提交和快照隔离级别，两个并发的写入事务可能会发生下图所示的丢失更新（lost update）问题。两个用户同时增加一个计数器，计数器应该从42增加到44，却因为并发问题只增加到43。

![DistributedData LostUpdateExample](/assets/img/DDIA_DistributedData_LostUpdateExample.png)

只要应用程序从数据库读取一些值，修改并写回修改的值（“读取-修改-写入”），就可能会发生丢失更新。

#### 原子写

许多数据库提供了原子更新操作，可以避免应用程序执行“读取-修改-写入”，从而避免丢失更新。例如，下列执行在大多数关系数据库中是并发安全的：

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

原子操作的实现方式有两种：
1. 游标稳定性（cursor stability）：读取对象时，获取该对象的排它锁，在更新完成前没有其他事务可以读取该对象。
2. 强制所有的原子操作在单一线程上执行。

#### 显式锁定

如果数据库的原子操作没有提供需要的功能，可以通过显式锁定要更新的对象来避免丢失更新。

如下所示，在一个多人游戏中，使用锁来防止两个玩家同时移动相同的棋子。其中，`FOR UPDATE`告诉数据库对查询返回的所有行加锁。

```sql
BEGIN TRANSACTION;
SELECT * FROM figures
  WHERE name = 'robot' AND game_id = 222
FOR UPDATE;

-- 检查玩家的操作是否有效，然后更新先前 SELECT 返回棋子的位置。
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```

#### 自动检测丢失更新

原子操作和显式锁定都是通过强制事务按顺序执行的方式，另一种方法是允许事务并发执行，当事务管理器检测到丢失更新，就中止事务并强制它们重试。

这种方法的优点：
- 数据库可以结合快照隔离，高效地执行检测。
- 原子操作和显式锁定都需要应用程序有意识地使用，可能会忘记，而丢失更新的检测是数据库自动发生的。

#### 比较并设置（CAS）

有些数据库会提供CAS操作，来避免丢失更新。如下所示，为了避免两个用户同时更新一个wiki页面，只在页面内容没有变化的情况下才去更新。

```sql
-- 根据数据库的实现情况，这可能安全也可能不安全
UPDATE wiki_pages SET content = '新内容'
  WHERE id = 1234 AND content = '旧内容';
```

这种方法的问题是，如果数据库允许`WHERE`子句从快照中读取，那即使发生了另一个并发写入，`WHERE`条件也为真，这样就没法避免丢失更新了。

#### 冲突解决

在多主和无主数据库中，并发写入可能发生在多个节点上，因此基于锁和CAS的方法都不再适用。常见做法是，允许并发写入创建多个冲突的版本，事后再去解决和合并这些版本。

### 写入偏差和幻读

在并发写入时，除了脏写和丢失更新，还可能会发生写入偏差。例子如下，Alice和Bob是两位值班医生，他们都想请假，并发写入导致他们都请假成功了，最后没有医生在值班，这显然是违反医院规定的。

![DistributedData WriteBiasExample](/assets/img/DDIA_DistributedData_WriteBiasExample.png)

写入偏差可以看成是丢失更新的一般化，在多个事务同时更新一个对象时可能会发生丢失更新，在多个事务同时更新不同对象时可能会发生写入偏差。

#### 防止写入偏差

防止写入偏差的方法有：
1. 一些数据库允许配置约束，如唯一性、特定值限制、外键约束等，然后由数据库强制执行。
2. 涉及多个对象的约束时，大多数数据库没有内置的支持，可以使用触发器、物化视图来实现约束。
3. 显式锁定事务所依赖的行，如下所示：
    ```sql
    BEGIN TRANSACTION;
    SELECT * FROM doctors
      WHERE on_call = TRUE
      AND shift_id = 1234
    FOR UPDATE;

    UPDATE doctors
      SET on_call = FALSE
      WHERE name = 'Alice'
      AND shift_id = 1234;
  
    COMMIT;
    ```
4. 使用可串行化隔离级别。

#### 导致写入偏差的幻读

幻读（phantoms）：一个事务中的写入改变了另一个事务的查询结果。

读取偏差就是一种幻读，使用快照隔离可以避免。

写入偏差也是一种幻读，它的常见模式为：
1. 首先查询找出所有符合条件的行（例如：某天值班的所有医生）。
2. 检查是否符合一些要求（例如：值班医生的数量是否超过2）。
3. 如果符合要求，就执行写入，并提交事务（例如：Alice请假成功）。

步骤3的写入可能会改变步骤2的结果，从而导致写入偏差。

#### 物化冲突（Materializing Conflicts）

解决幻读的方法之一是加锁。但是，如果没有对象可以加锁呢？

例如：在一个预定会议室的系统中，刚开始有一个会议室没有人预定，突然有两个人同时想要预定这个会议室，就可能会出现写入偏差。

解决办法：创建一个关于时间槽和房间的表，每一行对应特定时间段（如15分钟）的特定房间，提前插入未来几个月的时间和房间的所有可能行。创建预定的事务需要先锁定表中与时间和房间对应的行，从而防止冲突。

这种方法称为物化冲突，它把幻读变成了数据库中一组具体行上的锁冲突。

物化冲突会导致并发控制机制泄露到应用数据模型，比较丑陋，也容易出错，所以更推荐使用可串行化隔离级别。

## 可串行化

可串行化（Serializability）是最强的隔离级别，它保证多个事务并发执行的结果，和它们一个接一个执行的结果相同。可串行化可以防止所有的并发问题。

实现可串行化有三种技术：
- 真的串行执行事务
- 两阶段锁定
- 乐观并发控制，如可串行化快照隔离

### 真的串行执行事务

在单个线程上，按顺序一次执行一个事务。

单线程执行变得可能的两个条件：
- RAM足够便宜，许多场景都可以把完整的活跃数据集保存在内存中，因此事务执行的速度比数据存储上磁盘上的要快。
- OLTP（事务处理）通常只进行少量的读写操作，速度很快；OLAP（在线分析）虽然运行之间长，但是通常是只读的，可以在一致性快照上运行。

单线程执行的优缺点:
- 优点：完全绕开了并发问题。
- 缺点：吞吐量被限制为单机单核的速度。

有时候，单线程执行的系统会比支持并发的系统有更好的性能，因为可以避免锁的协调开销。

#### 在存储过程中封装事务

单线程执行的系统不允许交互式的多语句事务，应用程序必须提前把整个事务代码作为存储过程提交给数据库。两种方式的对比如下，存储过程和内存存储数据，可以避免网络和磁盘I/O，因此执行速度非常快。

![DistributedData StoredProcedure](/assets/img/DDIA_DistributedData_StoredProcedure.png)

#### 分区

单线程执行会导致吞吐量被限制为单机单核的速度，可能会成为一个瓶颈。

为了伸缩至多个CPU核和多个节点，可以对数据进行分区，并且为每个分区分配一个独立运行的事务处理线程。这样，事务吞吐量就可以随CPU核数而线性伸缩了。

对于需要访问多个分区的事务，数据库需要在所有分区之间协调事务，从而影响吞吐量。

### 两阶段锁定

两阶段锁定（2PL，two-phase locking）使用锁来防止并发问题，具体如下：
- 没有写入时，允许多个事务同时读取同一个对象。
- 有写入时，需要独占访问（exclussive access）的权限。
    - 如果事务A读取了一个对象，而事务B想要写入该对象，B必须等A结束才能继续。
    - 如果事务A写入了一个对象，而事务B想要读取该对象，B必须等A结束才能继续。

两阶段锁定的特点：读阻塞写，写阻塞读和其他写。

#### 实现2PL

为数据库中的每个对象添加锁，锁可以处于共享模式（shared mode）或独占模式（exclusive mode）。

锁的使用如下：
- 如果事务要读取一个对象，必须以共享模式获取锁。
    - 如果另一个事务已经持有该对象的共享锁，该事务依然可以获得共享锁。
    - 如果另一个事务已经持有该对象的排他锁，该事务需要等待。
- 如果事务要写入一个对象，必须以独占模式获取锁。
    - 如果另一个事务已经持有该对象的锁（无论是共享锁还是排他锁），该事务需要等待。
- 如果事务要先读取再写入一个对象，需要把共享锁升级为独占锁，升级过程和直接获取独占锁一样。
- 事务获得锁之后，一直持有直到事务结果。

死锁（deadlock）：事务A等待事务B释放它的锁，事务B也等待事务A释放它的锁。

数据库会自动检测事务之间的死锁，并中止其中一个事务。

#### 2PL的性能

2PL的事务吞吐量和查询相应时间比弱隔离级别要差得多，原因在于：
- 锁的机制导致并发性的降低。
- 事务获取和释放锁都有开销。
- 由于使用的锁很多，可能会频繁出现死锁。

#### 谓词锁

为了防止幻读，需要使用谓词锁（predicate lock）。

谓词锁不属于特定的对象，而属于所有符合搜索条件的对象，如：

```sql
SELECT * FROM bookings
WHERE room_id = 123 AND
      end_time > '2018-01-01 12:00' AND
      start_time < '2018-01-01 13:00';
```

谓词锁也有共享模式和独占模式，锁的使用如下：
- 如果事务想要读取匹配某些条件的对象，必须获取查询条件上的共享谓词锁。如果另一个事务已经持有满足查询条件的任何对象的排它锁，那么该事务需要等待。
- 如果事务想要写入任何对象，必须检查旧值或新值是否与现有的谓词锁匹配。如果另一个事务持有匹配的谓词锁，那么该事务需要等待。

#### 索引范围锁

谓词锁的性能不好，当活跃事务持有很多锁的时候，检查匹配的锁会很耗时。

索引范围锁（index-range locking）是近似版的谓词锁，也可以用来防止幻读，而且开销更低。大部分2PL的数据库实际上使用的是索引范围锁。

索引范围锁基于两个想法：
1. 把谓词匹配到一个更大的集合来简化谓词锁。例如，对于在12:00-13:00之间预定1号房间的谓词锁，可以安全地简化为锁定12:00-13:00之间的所有房间，或者锁定1号房间的所有时间段。
2. 把搜索条件的近似值附加到一个索引上。例如，数据库在房间号上有一个索引，可以把锁附加到这个索引项上，指示已有事务搜索1号房间用于预定。

如果有两个事务想要写入同一个房间和同一个时间段的预定，它们必须更新索引的相同部分，这时就会遇到锁，必须有一个事务要等待。

### 可串行化快照隔离

与串行执行和2PL不同，可串行化快照隔离（SSI，Serialiable Snapshot Isolation）的性能比较好，与快照隔离相比只有很小的性能损失。

#### 并发控制：悲观 VS. 乐观

悲观并发控制：如果事情有可能出错，最好等到安全后再做。串行执行和2PL都属于悲观的并发控制。

乐观并发控制：即使有可能出错，也不阻止事务，而是继续实行。直到提交时，再去检查是否会出错，并在会出错时中止事务。SSI属于乐观并发控制。

争用（contention）：很多事务试图访问相同的对象。

如果数据库系统有很多空闲容量，并且事务之间的争用不多，那么乐观并发控制的性能会比悲观并发控制更好。反之，如果系统容量已经接近最大吞吐量，并且存在很多争用，那么乐观并发控制的性能会比较差。

#### 实现SSI

SSI基于快照隔离，事务中的所有读取都来自一致性快照。在此基础上，添加了一种算法来检测写入之间的冲突，并确定要中止哪些事务。

发生写入偏差的情况通常满足这样的模式：从数据库读取一些数据，检查数据是否满足某些条件，根据结果决定是否写入。在这种模式下，事务是基于一个前提（premise）采取行动的，但是提交时这个前提可能已经过时了。数据库需要检测出这种情况，并且中止事务。

由于数据库不知道应用程序会怎么使用查询结果，需要假设任何对查询结果的变更都可能会导致该事务的写入出现并发问题。

为了检测过时的前提，需要考虑两种情况：
- 检测对旧MVCC对象版本的读取：在事务读取数据前存在没提交的写入，在事务提交前该写入提交了。
- 检测影响先前读取的写入：在事务读取数据之后发生写入，并提交了。

#### 检测对旧MVCC对象版本的读取

如下所示，当事务43读取数据时，由于事务42还没有提交，会忽略事务42的写入。然而，当事务43提交时，事务42已经在它之前提交了，这意味之前忽略的写入已经生效，前提已经过时，所以需要中止事务43。

![DistributedData ReadFromOldMVCC](/assets/img/DDIA_DistributedData_ReadFromOldMVCC.png)

数据库需要跟踪一个事务由于MVCC可见性规则而忽略的另一个事务的写入，当该事务想要提交时，检查被忽略的写入是否有被提交的，如果有就需要中止该事务。

为什么不在检测到事务读取了旧版本的数据就中止，而是等到事务提交时才中止呢？有两个原因：
- 如果事务43是只读的，不需要中止。
- 如果事务43提交时，事务42还没提交或者已经中止，那么事务42也不需要中止。

#### 检测影响先前读取的写入

如下所示，当事务42和43读取数据时，如果在`shift_id`上有索引，就使用索引项1234来记录事务42和43读取这个数据的事实（如果没有索引，就在表级别记录）。这个信息只需要保留一段时间，当所有的并发事务完成之后，就可以删掉了。

当事务写入数据库时，需要在索引中查找最近曾读取过受影响数据的其他事务，并通知它们先前的读取已经过时。在下图中，事务42写入时，会通知事务43读取已经过时，事务43写入时也会通知事务42。最后，由于事务42先提交，所以事务43会被中止。

![DistributedData WriteAffectPreviousRead](/assets/img/DDIA_DistributedData_WriteAffectPreviousRead.png)

#### SSI的性能

与2PL相比，SSI的最大优点是一个事务不需要等待另一个事务所持有的锁。和快照隔离一样，读不阻塞写，写也不阻塞读。这样查询延迟更加可预测，波动更少。SSI特别适合读取繁重的场景，因为只读查询可以运行在一致性快照上，不需要任何锁定。

与串行执行相比，SSI不局限于单个CPU核的吞吐量。SSI还可以把冲突检测分布到多台机器上，从而扩展到很高的吞吐量。

对于慢事务，SSI比2PL和串行执行更加不敏感。

事务中止率对SSI的性能影响很大。长时间读取和写入的事务很可能会发生冲突并中止，所以SSI要求同时读写的事务尽可能快。