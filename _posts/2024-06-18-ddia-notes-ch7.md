---
layout: post
title: DDIA阅读笔记(7)：分布式数据系统的事务
date: 2024-06-18 +0800
tags: [系统设计, DDIA]
categories: [系统设计]
---

## 事务的概念

事务（transaction）是应用程序把多个读写操作组合成一个逻辑单元的方式。

### ACID的含义

事务提供的安全保证，可以用ACID来描述。

#### A：原子性（Atomicity）

原子性的含义：当事务中有多个写操作，进行到一半时出现故障，数据库能够中止事务，并且丢弃该事务的所有写入。

原子性提供了all-or-nothing的保证，使应用程序不用担心部分失败的情况。

#### C：一致性（Consistency）

一致性的含义：对数据的一组特定约束必须始终成立，即不变式（invariants）。

一致性取决于应用程序，而不是数据库。应用程序需要理解不变式，并正确定义事务。

#### I：隔离性（Isolation）

隔离性的含义：同时执行的事务是互相隔离的，不会互相干扰。如果一个事务进行多个写操作，另一个事务要么看到全部写入的结果，要么什么也看不到。

隔离性可以理解为可串行化（serializability），即当多个事务并发运行时，结果与它们串行运行是一样的。

#### D：持久性（Durability）

持久性的含义：一旦事务成功完成，即使数据库崩溃或者硬件故障了，写入的数据也不会丢失。

在单节点数据库中，持久性通过以下方式来实现：
- 把数据写入非易失性存储设备，如硬盘、SSD。
- 同时把数据写入预写日志，这样可以在数据库崩溃时进行恢复。

在分布式数据库中，持久性的实现方式：等数据被成功复制到多个节点，才报告事务成功。

完美的持久性是不存在。如果所有硬盘和备份都被销毁了，数据肯定就丢失了。

### 单对象和多对象操作

一般数据库对单个节点的单个对象都提供事务保证。有些数据库还会提供更复杂的原子操作，例如：
- 原子自增：在并发的情况下，每次把值增加1。
- 比较和设置（CAS，compare-and-set）：只有在值没有被其他并发修改过时，才执行写操作。

多对象操作也需要事务，例如：
- 在关系数据库中，一个表中的行具有对另一个表中的行的外键引用，更改时需要保证外键正确。
- 在文档数据库中，一个字段可能同时存储在多个文档中，更新该字段时需要保证多个文档中的值都被更新。
- 如果数据库中有次级索引，更新数据时需要同时更新次级索引。

许多分布式数据库没有多对象事务，因为实现比较困难，并且可能会影响可用性。

## 弱隔离级别

当两个事务同时修改一个数据，或者当一个事务读取由另一个事务同时修改的数据时，会出现并发问题。数据库通过事务隔离来隐藏应用开发者的并发问题。

事务的隔离级别可以分为：
- 可串行化：事务的运行结果就像串行运行的一样。会导致性能损失。
- 弱隔离级别：防止一部分而不是所有的并发问题。

### 读已提交（Read Committed）

读已提交是最基本的事务隔离级别，提供了两个保证：
- 没有脏读（dirty reads）：从数据库读时，只能看到已提交的数据。
- 没有脏写（dirty writes）：写入数据库时，只会覆盖已提交的数据。

#### 没有脏读

下图是一个脏读的例子。用户1给用户2发了一封新邮件，会给用户2产生一封未读邮件，并更新未读邮件的计数器。然而，脏读导致用户2只看到了新邮件，却没看到未读邮件的计数器更新。

![DistributedData DirtyReadExample](/assets/img/DDIA_DistributedData_DirtyReadExample.png)

防止脏读的原因：
- 如果事务需要更新多个对象，脏读会导致另一个事务只看到部分更新，造成困惑。
- 如果事务中止，所有写入操作都需要回滚，脏读会导致另一个事务看到需要回滚的数据，造成困惑。

#### 没有脏写

下图是一个脏写的例子。Alice和Bob同时买一辆车，而买车时需要两次数据库写入，一次写入买家，一次写入发票接收人。脏读会导致买家为Bob，而发票接收人为Alice。

![DistributedData DirtyWriteExample](/assets/img/DDIA_DistributedData_DirtyWriteExample.png)

#### 实现读已提交

防止脏写的常见方法是使用行锁（row-level lock）。当事务想要修改某个对象时，首先获得该对象的锁，然后持有到事务完成为止。如果另一个事务也想修改这个对象，就必须等到第一个事务完成后，才能获得锁并继续。使用行锁的过程由数据库自动完成。

防止脏读有两种办法：
1. 使用行锁。如果事务想要读取某个对象，也必须获得该对象的锁。如果另一个进行写入的事务先获得了该锁，进行读取的事务就必须等待。这种方法不好，会影响性能。
2. 返回旧的已提交值。如果事务正在更新某个对象，数据库会记录旧的已提交值，和该事务设置的新值。此时如果另一个事务想要读取这个对象，数据库会返回旧值。

### 快照隔离（Snapshot Isolation）和可重复读（Repeatable Read）

读已提交只是最基本的隔离级别，在使用读已提交时，可能会发生下图所示的异常。

Alice在银行有两个账户，分别有500块。有一个正在执行的事务，把100块从一个账户转移到另一个账户。在事务开始前和结束后，Alice分别查看了两个账户的余额，她发现加起来只有900块了。

这种异常称为读取偏差（read skew），或不可重复读（nonrepeatable read）。

![DistributedData ReadSkewExample](/assets/img/DDIA_DistributedData_ReadSkewExample.png)

对于Alice来说，这个异常是暂时的，只要她过一会儿再重新查询，就能看到正确的余额了。

但是，有些情况是不允许这种读取偏差的：
- 数据库备份：数据库备份可能要花比较长的时间，备份期间是仍然允许写入的。如果备份中包含一些旧的部分和一些新的部分，从这个备份中恢复数据库会导致永久性的数据不一致。
- 分析查询和完整性检查：在进行数据分析和完整性检查时，如果查询到的数据一部分是旧的，一部分是新的，那得到的结果可能毫无意义。

解决读取偏差的常见方法是快照隔离。数据库在特定时间点冻结一致快照（consistent snapshot），每个事务都从一致快照读取数据。

#### 实现快照隔离

防止脏写的办法和读已提交一样，使用行锁。

防止脏读的办法也类似于读已提交，数据库保留一个对象的多个提交版本，从而让各种正在进行的事务可以读取不同时间点的数据。这种技术称为多版本并发控制（MVCC，multi-version concurrency control）。

下图说明了PostgreSQL是怎么基于MVCC实现快照隔离的。

![DistributedData MVCCExample](/assets/img/DDIA_DistributedData_MVCCExample.png)

- 每个事务开始时，都会被赋予一个唯一的、递增的事务ID（即图中的txid）。
- 当事务向数据库写入时，会在写入的数据上标记该事务的ID，例如：插入数据时，设置`create by`为事务ID，`deleted by`为空；删除数据时，并不会真正删除，而是把`deleted by`设置为事务ID。
- `UPDATE`操作被翻译为`DELETE`和`CREATE`。
- 数据库的垃圾收集过程负责清除那些被标记为删除的数据。

当一个事务从数据库读取时，事务ID决定它可以看见哪些对象，看不见哪些对象。可见性规则如下：
1. 在事务开始时，数据库列出所有正在进行的其他事务，忽略它们的任何写入（即使之后提交了）。
2. 对于事务ID更大的所有事务，忽略它们的任何写入（即使已经提交了）。
3. 对于被中止的事务，忽略它们的任何写入。
4. 除此以外的其他写入都是可见的。

总结来说，只要以下两个条件都成立，那么一个对象就是可见的：
- 读取的事务开始时，已经有事务创建这个对象并提交。
- 读取的事务开始时，没有事务删除这个对象并提交。

快照隔离是读已提交的一般化。快照隔离需要保留一个对象的多个版本，而读已提交只需要保留两个版本：已提交的版本，被覆盖但还没提交的版本。支持快照隔离的数据库通常也会使用MVCC来实现读已提交。

#### 索引如何工作？

在使用MVCC的数据库中，索引有两种工作方式：

1. 索引指向对象的所有版本，查询时过滤掉当前事务不可见的版本。当垃圾收集过程删除旧版本时，同时删除相应的索引条目。
2. 使用就追加的B树，每个写入事务（或一批事务）创建一颗新的B树，作为数据库的一个一致快照。

### 丢失更新

### 写入偏差和幻读