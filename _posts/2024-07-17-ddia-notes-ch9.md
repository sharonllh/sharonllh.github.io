---
layout: post
title: DDIA阅读笔记(9)：分布式数据系统的一致性与共识
date: 2024-07-17 +0800
tags: [系统设计, DDIA]
categories: [系统设计]
---

共识（consensus）：所有节点对某件事达成一致。

共识是分布式系统最重要的抽象之一。一旦达成共识，应用可以将其用于各种目的。例如，对于一个单主复制的数据库，如果主库挂掉了，需要切换到另一个节点，剩余的节点可以使用共识来推举新的领导者。

## 一致性保证

最终一致性：所有副本最终会收敛到相同的值。这意味着，如果停止向数据库写入数据并等待一段时间，最终所有的读取请求都会返回相同的值。这个保证非常弱，因为它并不保证什么时候副本会收敛。

更强的一致性保证可能具有更差的性能和更少的容错性。

## 线性一致性

线性一致性（linearizability）：又称强一致性（strong consistency），基本思想是让系统看起来好像只有一个数据副本，并且所有操作都是原子性的。

如下所示，为了实现线性一致性，需要满足以下条件：
- 如果读操作在写操作之前完成，必须返回旧值。例如，客户端A的第一次读取返回0。
- 如果读操作在写操作之后完成，必须返回新值。例如，客户端A的第三次读取返回1。
- 如果读操作和写操作同时发生，可能返回旧值或新值。然而，一旦一个客户端的读取返回新值，所有后续读取都必须返回新值。例如，客户端B的第一次读取返回0，但是客户端A的第二次读取返回1，所以客户端B的第二次读取也必须返回1。

![DistributedData LinearizabilityExample](/assets/img/DDIA_DistributedData_LinearizabilityExample.png)

### 依赖线性一致性的例子

- 分布式锁和领导者选举
- 唯一性约束，例如用户名必须是唯一的
- 跨信道的时序依赖，例如有一个网站，在用户上传照片后，会先把照片存储到数据库，然后发送消息到消息队列，让图像缩放器把照片缩小。如果数据库不是线性一致的，图像缩放器在收到消息后，可能没法从数据库拿到照片。

### 实现线性一致的系统

- 单主复制：可能是线性一致的。例如，使用了快照隔离的系统，在写操作完成后，读操作依然可能返回旧值。
- 共识算法：是线性一致的。
- 多主复制：不是线性一致的。
- 无主复制：可能是线性一致的。

### 线性一致性的代价

假设某些副本因为网络问题和其他副本断开连接：
- 如果应用需要线性一致性，那么这些副本必须等待网络恢复才能处理请求，因为可能会返回旧值。
- 如果应用不需要线性一致性，那么这些副本依然可以独立处理请求。

因此，不需要线性一致性的系统有更强的容错能力。

另外，线性一致性还会影响系统的性能，增加读写请求的响应时间。

### CAP定理

- C：一致性
- A：可用性
- P：分区容错性

CAP定理可以简单表述为：一致性、可用性和分区容错性只能选择两个。CAP定理是一个经验法则，描述数据库的权衡。

CAP定理不够精确，应该避免使用。

## 顺序保证

### 顺序（ordering）和因果关系（causality）

因果关系对事件施加了一种顺序：因在果之前。例如，对话的观察者必须先看到问题，再看到答案。

因果一致性：系统服从因果关系所规定的顺序。

#### 因果顺序是偏序的

全序（total order）：任意两个元素是可以比较的。例如，自然数集中的任意两个数是可以比较大小的。

偏序（partially order）：有些情况下两个元素是可以比较的，有些情况则不可以。例如，可以比较两个集合大小吗？如果一个集合包含另一个集合，那是可以比较大小的，但是如果它们没有包含关系，就是不可比较的。

线性一致系统：操作是全序的。对于任意两个操作，总是能判断哪个先发生。

因果一致系统：操作是偏序的。如果两个操作是并发的，它们之间没有因果联系，无法判断哪个先发生。

#### 线性一致性强于因果一致性

线性一致的系统必然因果一致，但因果一致的系统不一定线性一致。

#### 非线性一致的系统如何保持因果顺序？

1. 需要确定哪些操作发生在其他操作之前。
2. 如果一个操作发生在另一个操作之前，那必须在所有副本上按照这个顺序来处理。
3. 如果两个操作是并发的，可以用任意顺序来处理。

### 序列号顺序

跟踪所有的因果关系是不实际的，因为客户端在写入前可能会读取大量的数据，我们无法确定写入是否因果依赖于所有的数据，而跟踪所有的已读数据会造成很大的开销。

更好的方法是，使用序列号（sequence number）来排序事件。序列号提供了一个全序关系，两个操作的序列号总是可以比较大小的。

因果一致的序列号：如果操作A因果地发生在操作B之前，那么A的序列号一定比B小。

#### 非因果序列号生成器

在单主复制的数据库中，主库可以使用自增的计数器，为每个操作分配一个单调递增的序列号，这样生成的序列号是因果一致的。

在多主复制和无主复制的数据库中，或者在使用分区的数据库中，没有单一的主库，生成序列号的常见方法有：
- 在序列号的二进制表示中预留一些位，用来标识节点，让每个节点都可以生成自己独立的序列号。
- 使用日历时钟的时间戳。
- 预先分配序列号区块，例如，节点A请求序列号1~1000的使用权，节点B请求序列号1001~2000的使用权，每个节点可以独立分配所拥有的区块中的序列号，并在序列号快用完时请求分配新的区块。

这三种方式生成的序列号都是非因果一致的。

#### 兰伯特时间戳



### 全序广播

## 分布式事务与共识